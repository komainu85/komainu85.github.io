<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="/assets/css/style.css?v=921f65196db0b9db054ecf34dedaa571dd6f74f2" media="screen" type="text/css">
    <link rel="stylesheet" href="/assets/css/print.css" media="print" type="text/css">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

<!-- Begin Jekyll SEO tag v2.2.3 -->
<title>Sitecore Item Web API XML Maintaining Sitecore SPEAK | Mike Robbins</title>
<meta property="og:title" content="Sitecore Item Web API XML Maintaining Sitecore SPEAK" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Recently I have had a client request asking to use Sitecore Item Web API in XML format rather than JSON. Luckily within the Item Web API documentation Sitecore provide a Pipeline Processor to output XML rather than JSON.  http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf Sitecore SPEAK also makes use of the Sitecore Item Web API, but an unfortunate side effect of this code snippet is that it breaks Sitecore SPEAK as it expects JSON responses back from the web service. The code snippet below is an adapted version of the Sitecore code snippet. It allows bypassing the XMLSerializer by default unless a query string parameter of &quot;type=xml&quot; is present. This allows you to maintain Sitecore SPEAK functionality while allowing the calling client to easily switch between JSON and XML. Add this XML to the include folder in app_config [code language=&quot;xml&quot;] &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration xmlns:patch=&quot;http://www.sitecore.net/xmlconfig/&quot;&gt; &lt;sitecore&gt; &lt;pipelines&gt; &lt;itemWebApiRequest&gt; &lt;processor patch:before=&quot;*[@type=&#39;Sitecore.ItemWebApi.Pipelines.Request.SerializeResponse, Sitecore.ItemWebApi&#39;]&quot; type=&quot;MikeRobbins.CMS.WebItemAPI.SwitchToXmlSerializer,MikeRobbins.CMS&quot; /&gt; &lt;/itemWebApiRequest&gt; &lt;/pipelines&gt; &lt;/sitecore&gt; &lt;/configuration&gt;[/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class SwitchToXmlSerializer : RequestProcessor { public override void Process([NotNull] RequestArgs arguments) { if (System.Web.HttpContext.Current.Request.QueryString[&quot;type&quot;] == &quot;xml&quot;) { Context.Current.Serializer = new XmlSerializer(); } } } } [/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class XmlSerializer : ISerializer { public string SerializedDataMediaType { get { return &quot;text/xml&quot;; } } public string Serialize(object value) { return Serialize((Dynamic)value).ToString(); } private XElement Serialize(Dynamic value) { var element = XElement.Parse(&quot;&lt;object/&gt;&quot;); foreach (var property in value) { var propertyName = string.Format(&quot;_{0}&quot;, property.Key); propertyName = propertyName.Replace(&quot;{&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot;}&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot; &quot;, &quot;-&quot;); var child = XElement.Parse(string.Format(&quot;&lt;{0}/&gt;&quot;, propertyName)); var array = property.Value as Dynamic[]; if (array != null) { foreach (var item in array) { child.Add(Serialize(item)); } } else if (property.Value is Dynamic) { child.Add(Serialize((Dynamic)property.Value)); } else { child.Add(property.Value.ToString()); } element.Add(child); } return element; } } }[/code]" />
<meta property="og:description" content="Recently I have had a client request asking to use Sitecore Item Web API in XML format rather than JSON. Luckily within the Item Web API documentation Sitecore provide a Pipeline Processor to output XML rather than JSON.  http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf Sitecore SPEAK also makes use of the Sitecore Item Web API, but an unfortunate side effect of this code snippet is that it breaks Sitecore SPEAK as it expects JSON responses back from the web service. The code snippet below is an adapted version of the Sitecore code snippet. It allows bypassing the XMLSerializer by default unless a query string parameter of &quot;type=xml&quot; is present. This allows you to maintain Sitecore SPEAK functionality while allowing the calling client to easily switch between JSON and XML. Add this XML to the include folder in app_config [code language=&quot;xml&quot;] &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration xmlns:patch=&quot;http://www.sitecore.net/xmlconfig/&quot;&gt; &lt;sitecore&gt; &lt;pipelines&gt; &lt;itemWebApiRequest&gt; &lt;processor patch:before=&quot;*[@type=&#39;Sitecore.ItemWebApi.Pipelines.Request.SerializeResponse, Sitecore.ItemWebApi&#39;]&quot; type=&quot;MikeRobbins.CMS.WebItemAPI.SwitchToXmlSerializer,MikeRobbins.CMS&quot; /&gt; &lt;/itemWebApiRequest&gt; &lt;/pipelines&gt; &lt;/sitecore&gt; &lt;/configuration&gt;[/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class SwitchToXmlSerializer : RequestProcessor { public override void Process([NotNull] RequestArgs arguments) { if (System.Web.HttpContext.Current.Request.QueryString[&quot;type&quot;] == &quot;xml&quot;) { Context.Current.Serializer = new XmlSerializer(); } } } } [/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class XmlSerializer : ISerializer { public string SerializedDataMediaType { get { return &quot;text/xml&quot;; } } public string Serialize(object value) { return Serialize((Dynamic)value).ToString(); } private XElement Serialize(Dynamic value) { var element = XElement.Parse(&quot;&lt;object/&gt;&quot;); foreach (var property in value) { var propertyName = string.Format(&quot;_{0}&quot;, property.Key); propertyName = propertyName.Replace(&quot;{&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot;}&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot; &quot;, &quot;-&quot;); var child = XElement.Parse(string.Format(&quot;&lt;{0}/&gt;&quot;, propertyName)); var array = property.Value as Dynamic[]; if (array != null) { foreach (var item in array) { child.Add(Serialize(item)); } } else if (property.Value is Dynamic) { child.Add(Serialize((Dynamic)property.Value)); } else { child.Add(property.Value.ToString()); } element.Add(child); } return element; } } }[/code]" />
<link rel="canonical" href="http://localhost:4000/developer/sitecore/speak/web%20item%20api/2014/05/09/sitecore-item-web-api-xml-maintaining-sitecore-speak.html" />
<meta property="og:url" content="http://localhost:4000/developer/sitecore/speak/web%20item%20api/2014/05/09/sitecore-item-web-api-xml-maintaining-sitecore-speak.html" />
<meta property="og:site_name" content="Mike Robbins" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-05-09T10:57:53+01:00" />
<script type="application/ld+json">
{"@context":"http://schema.org","@type":"BlogPosting","headline":"Sitecore Item Web API XML Maintaining Sitecore SPEAK","author":{"@type":"Person","name":null},"datePublished":"2014-05-09T10:57:53+01:00","dateModified":"2014-05-09T10:57:53+01:00","description":"Recently I have had a client request asking to use Sitecore Item Web API in XML format rather than JSON. Luckily within the Item Web API documentation Sitecore provide a Pipeline Processor to output XML rather than JSON.  http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf Sitecore SPEAK also makes use of the Sitecore Item Web API, but an unfortunate side effect of this code snippet is that it breaks Sitecore SPEAK as it expects JSON responses back from the web service. The code snippet below is an adapted version of the Sitecore code snippet. It allows bypassing the XMLSerializer by default unless a query string parameter of &quot;type=xml&quot; is present. This allows you to maintain Sitecore SPEAK functionality while allowing the calling client to easily switch between JSON and XML. Add this XML to the include folder in app_config [code language=&quot;xml&quot;] &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;configuration xmlns:patch=&quot;http://www.sitecore.net/xmlconfig/&quot;&gt; &lt;sitecore&gt; &lt;pipelines&gt; &lt;itemWebApiRequest&gt; &lt;processor patch:before=&quot;*[@type=&#39;Sitecore.ItemWebApi.Pipelines.Request.SerializeResponse, Sitecore.ItemWebApi&#39;]&quot; type=&quot;MikeRobbins.CMS.WebItemAPI.SwitchToXmlSerializer,MikeRobbins.CMS&quot; /&gt; &lt;/itemWebApiRequest&gt; &lt;/pipelines&gt; &lt;/sitecore&gt; &lt;/configuration&gt;[/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class SwitchToXmlSerializer : RequestProcessor { public override void Process([NotNull] RequestArgs arguments) { if (System.Web.HttpContext.Current.Request.QueryString[&quot;type&quot;] == &quot;xml&quot;) { Context.Current.Serializer = new XmlSerializer(); } } } } [/code] [code language=&quot;csharp&quot;] namespace MikeRobbins.CMS.WebItemAPI { public class XmlSerializer : ISerializer { public string SerializedDataMediaType { get { return &quot;text/xml&quot;; } } public string Serialize(object value) { return Serialize((Dynamic)value).ToString(); } private XElement Serialize(Dynamic value) { var element = XElement.Parse(&quot;&lt;object/&gt;&quot;); foreach (var property in value) { var propertyName = string.Format(&quot;_{0}&quot;, property.Key); propertyName = propertyName.Replace(&quot;{&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot;}&quot;, &quot;&quot;); propertyName = propertyName.Replace(&quot; &quot;, &quot;-&quot;); var child = XElement.Parse(string.Format(&quot;&lt;{0}/&gt;&quot;, propertyName)); var array = property.Value as Dynamic[]; if (array != null) { foreach (var item in array) { child.Add(Serialize(item)); } } else if (property.Value is Dynamic) { child.Add(Serialize((Dynamic)property.Value)); } else { child.Add(property.Value.ToString()); } element.Add(child); } return element; } } }[/code]","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/developer/sitecore/speak/web%20item%20api/2014/05/09/sitecore-item-web-api-xml-maintaining-sitecore-speak.html"},"url":"http://localhost:4000/developer/sitecore/speak/web%20item%20api/2014/05/09/sitecore-item-web-api-xml-maintaining-sitecore-speak.html"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>
    <header>
      <div class="inner">
        <a href="http://localhost:4000/">
          <h1>Mike Robbins</h1>
        </a>
        <h2>Sitecore Developer Blog
</h2>
        
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>Sitecore Item Web API XML Maintaining Sitecore SPEAK</h1>
          <p>Recently I have had a client request asking to use Sitecore Item Web API in XML format rather than JSON. Luckily within the Item Web API documentation Sitecore provide a Pipeline Processor to output XML rather than JSON.  <a title="http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf" href="http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf" target="_blank">http://sdn.sitecore.net/upload/sdn5/modules/sitecore%20item%20web%20api/sitecore_item_web_api_developer_guide_sc66-71-a4.pdf</a></p>
<p>Sitecore SPEAK also makes use of the Sitecore Item Web API, but an unfortunate side effect of this code snippet is that it breaks Sitecore SPEAK as it expects JSON responses back from the web service. The code snippet below is an adapted version of the Sitecore code snippet. It allows bypassing the XMLSerializer by default unless a query string parameter of "type=xml" is present.</p>
<p>This allows you to maintain Sitecore SPEAK functionality while allowing the calling client to easily switch between JSON and XML. Add this XML to the include folder in app_config</p>
<p>[code language="xml"]<br />
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;<br />
&lt;configuration xmlns:patch=&quot;http://www.sitecore.net/xmlconfig/&quot;&gt;<br />
 &lt;sitecore&gt;<br />
 &lt;pipelines&gt;<br />
 &lt;itemWebApiRequest&gt;<br />
 &lt;processor patch:before=&quot;*[@type='Sitecore.ItemWebApi.Pipelines.Request.SerializeResponse, Sitecore.ItemWebApi']&quot; type=&quot;MikeRobbins.CMS.WebItemAPI.SwitchToXmlSerializer,MikeRobbins.CMS&quot; /&gt;<br />
 &lt;/itemWebApiRequest&gt;<br />
 &lt;/pipelines&gt;<br />
 &lt;/sitecore&gt;<br />
&lt;/configuration&gt;[/code]</p>
<p>[code language="csharp"]<br />
namespace MikeRobbins.CMS.WebItemAPI<br />
{<br />
 public class SwitchToXmlSerializer : RequestProcessor<br />
 {<br />
 public override void Process([NotNull] RequestArgs arguments)<br />
 {<br />
 if (System.Web.HttpContext.Current.Request.QueryString[&quot;type&quot;] == &quot;xml&quot;)<br />
 {<br />
 Context.Current.Serializer = new XmlSerializer();<br />
 }<br />
 }<br />
 }<br />
}<br />
[/code]</p>
<p>[code language="csharp"]<br />
namespace MikeRobbins.CMS.WebItemAPI<br />
{<br />
 public class XmlSerializer : ISerializer<br />
 {<br />
 public string SerializedDataMediaType<br />
 {<br />
 get<br />
 {<br />
 return &quot;text/xml&quot;;<br />
 }<br />
 }</p>
<p> public string Serialize(object value)<br />
 {<br />
 return Serialize((Dynamic)value).ToString();<br />
 }</p>
<p> private XElement Serialize(Dynamic value)<br />
 {<br />
 var element = XElement.Parse(&quot;&lt;object/&gt;&quot;);</p>
<p> foreach (var property in value)<br />
 {<br />
 var propertyName = string.Format(&quot;_{0}&quot;, property.Key);<br />
 propertyName = propertyName.Replace(&quot;{&quot;, &quot;&quot;);<br />
 propertyName = propertyName.Replace(&quot;}&quot;, &quot;&quot;);<br />
 propertyName = propertyName.Replace(&quot; &quot;, &quot;-&quot;);</p>
<p> var child = XElement.Parse(string.Format(&quot;&lt;{0}/&gt;&quot;, propertyName));<br />
 var array = property.Value as Dynamic[];</p>
<p> if (array != null)<br />
 {<br />
 foreach (var item in array)<br />
 {<br />
 child.Add(Serialize(item));<br />
 }<br />
 }<br />
 else if (property.Value is Dynamic)<br />
 {<br />
 child.Add(Serialize((Dynamic)property.Value));<br />
 }<br />
 else<br />
 {<br />
 child.Add(property.Value.ToString());<br />
 }</p>
<p> element.Add(child);<br />
 }</p>
<p> return element;<br />
 }<br />
 }<br />
}[/code]</p>

        </section>

        <aside id="sidebar">
          <h3>About Me</h3>
          <p>Senior Product Developer at Sitecore</p>
          <p>Sitecore MVP 2015 / 2016</p>
       
        <h3>Tags</h3>
        <p>
            
              JSON,</li>
            
              Sitecore 7.2,</li>
            
              Sitecore SPEAK,</li>
            
              XML,</li>
            
        </p>
    
        <h3>Other Reading</h3>
         
        <h2 id=""></h2>
        <ul class="post-list">
            
          
          
          
        </ul>
       
        <h2 id=""></h2>
        <ul class="post-list">
            
          
          
          
        </ul>
       
        <h2 id=""></h2>
        <ul class="post-list">
            
          
          
          
        </ul>
       
        <h2 id=""></h2>
        <ul class="post-list">
            
          
          
          
        </ul>
      

      <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a>.</p>
      
           </aside>

      </div>
    </div>

    
  </body>
</html>