<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-08-18T20:28:46+01:00</updated><id>http://localhost:4000/</id><title type="html">Mike Robbins</title><subtitle>Sitecore Developer Blog
</subtitle><entry><title type="html">Windows 10 IoT to XDB with Sitecore SSC</title><link href="http://localhost:4000/iot/sitecore/sitecore.services.client/web%20item%20api/2016/03/07/windows-10-iot-to-xdb-with-sitecore-ssc.html" rel="alternate" type="text/html" title="Windows 10 IoT to XDB with Sitecore SSC" /><published>2016-03-07T13:41:31+00:00</published><updated>2016-03-07T13:41:31+00:00</updated><id>http://localhost:4000/iot/sitecore/sitecore.services.client/web%20item%20api/2016/03/07/windows-10-iot-to-xdb-with-sitecore-ssc</id><content type="html" xml:base="http://localhost:4000/iot/sitecore/sitecore.services.client/web%20item%20api/2016/03/07/windows-10-iot-to-xdb-with-sitecore-ssc.html">&lt;p&gt;Recently i've been playing with Windows 10 IoT Core, i've wondered if its possible to use the Raspberry Pi in some way with Sitecore.&lt;/p&gt;
&lt;p&gt;The idea i've had, was to create a kiosk style application to capture a user information at an event and post this data into Sitecore's xDB.  This kiosk application could be used as a competition encouraging the users to submit the form, and allow reporting from xDB who visited the event.&lt;/p&gt;
&lt;p&gt;Any data captured and sent to Sitecore xDB can then be used to personalise the experience for the user.&lt;/p&gt;
&lt;h2&gt;The Frameworks&lt;/h2&gt;
&lt;h3&gt;Windows Universal Platform&lt;/h3&gt;
&lt;p&gt;On the kiosk side, this demo application is written using Windows Universal Platform (UWP) framework running on a Raspberry Pi (2 or 3) on Windows 10 core.&lt;/p&gt;
&lt;p&gt;The power of Windows Universal Platform means we can write our code once and run the application on multiple platforms. For example this code will work on Windows 10, Windows Phone, Windows IoT devices such as the Raspberry Pi and coming soon, the Xbox One.&lt;/p&gt;
&lt;p&gt;Windows 10 for the Raspberry Pi and instructions for setting up Windows 10 and Visual Studio 2015 for Windows Universal Platform can be found here. &lt;a href=&quot;http://ms-iot.github.io/content/en-US/Downloads.htm&quot;&gt;http://ms-iot.github.io/content/en-US/Downloads.htm&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Sitecore - Sitecore.Services.Client&lt;/h3&gt;
&lt;p&gt;For the communication between the IoT application and Sitecore it makes perfect sense to use Web API. Luckily Sitecore has its own Web API based framework under the Sitecore.Services.Client (SSC) namespace.&lt;/p&gt;
&lt;p&gt;With Entity Service within Sitecore.Services.Client (SSC) all the authentication around access the rest end point is handled for us, along with model validation.&lt;/p&gt;
&lt;p&gt;The power in Entity Service comes where we can implement our own logic for the controller, we still have access to the full Sitecore API and in this case the xDB APIs.&lt;/p&gt;
&lt;h2&gt;Creating the xDB Web API end point with Entity Service (SSC)&lt;/h2&gt;
&lt;p&gt;The first thing we need for the kiosk application is to create a Entity Service controller and repository to expose and interact with data within Sitecore xDB.&lt;/p&gt;
&lt;p&gt;The first stage is to create our model we will expose on the Entity Service controller.Here we add all the properties from xDB we want to expose. This must implement EntityIdentity, this base class contains an ID, we will use this to store the xDB identifier for the user.&lt;/p&gt;
&lt;p&gt;Thanks to Jonathan Robbins and his &lt;a href=&quot;http://jonathanrobbins.co.uk/tag/xdb/&quot;&gt;xDB posts&lt;/a&gt; for working out some of this code.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/367ad1958365b0a2900c.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Next is our repository, here we will write the implementation code for working with xDB and the methods we want to expose over the API. The IRepository gives us the methods of our Entity Service API, so we can write the implementation for each of these methods. XdbFacetRepository is a class I have created for working with xDB, and can be seen below.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/95b4ef564984ad9394bd.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/e4bbacd23ee0b70251c3.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;The actual controller wires up the link between the Entity (Person), and the repository.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/6d59c90e379fa1274aec.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;h2&gt;Windows Universal Platform (Windows 10 IoT Core)&lt;/h2&gt;
&lt;p&gt;Now we have created the Entity Service API that allows us to post into xDB, the next step is to created a Windows Universal Platform (UWP) that can capture the data and post to our Entity Service.&lt;/p&gt;
&lt;p&gt;As I mentioned earlier Windows Universal Platform apps are restricted to Windows 10 IoT and can run on all Windows 10 based platforms.&lt;/p&gt;
&lt;p&gt;Below is a screen shot of the kiosk application I created, it captures a users first name, last name and email address. This has been created using the designer within Visual Studio 2015.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/kioskapplication.png&quot; alt=&quot;Windows Universal Application - Kiosk Application&quot;/&gt; 
&lt;/p&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;Windows Universal Application - Kiosk Application&lt;/p&gt;
&lt;p&gt;To get the form data into Sitecore xDB, we simply need to post to our Entity Service end point. We create a JSON string with our form data, here we are using the user's email address as the unique identifier. The JSON string can then be posted to our Entity Service end point.&lt;/p&gt;
&lt;p&gt;The authentication code to access the Entity Service isn't shown here for simplicity. I have written another blog on Sitecore.Services.Client authentication. &lt;a href=&quot;/entityservice/sitecore/sitecore.services.client/2016/01/14/sitecore-services-client-authentication.html&quot;&gt;Sitecore Services Client&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/d4f9fc7e91996ab7537d.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;The below video is an example of the finished kiosk posting data into Sitecore's xDB.&lt;/p&gt;
&lt;p style=&quot;text-align:center;&quot;&gt;&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/zRDuu99RB0Y&quot; frameborder=&quot;0&quot; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h2&gt;Up Next&lt;/h2&gt;
&lt;p&gt;In the next post I will look at creating a custom facet and updating the facet from an IoT application. I will create a VisitedEvent facet and update this facet when a user completes the kiosk form.&lt;/p&gt;
&lt;h2&gt;GitHub Source&lt;/h2&gt;
&lt;p&gt;Full source code is available on GitHub.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/komainu85/WindowsIoTSitecoreSSC&quot;&gt;https://github.com/komainu85/WindowsIoTSitecoreSSC&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="Entity Service" /><category term="EntityService" /><category term="Sitecore.Services.Client" /><category term="SSC" /><category term="UWP" /><category term="Windows 10 Core" /><category term="Windows Universal Platform" /><summary type="html">Recently i've been playing with Windows 10 IoT Core, i've wondered if its possible to use the Raspberry Pi in some way with Sitecore. The idea i've had, was to create a kiosk style application to capture a user information at an event and post this data into Sitecore's xDB.  This kiosk application could be used as a competition encouraging the users to submit the form, and allow reporting from xDB who visited the event. Any data captured and sent to Sitecore xDB can then be used to personalise the experience for the user. The Frameworks Windows Universal Platform On the kiosk side, this demo application is written using Windows Universal Platform (UWP) framework running on a Raspberry Pi (2 or 3) on Windows 10 core. The power of Windows Universal Platform means we can write our code once and run the application on multiple platforms. For example this code will work on Windows 10, Windows Phone, Windows IoT devices such as the Raspberry Pi and coming soon, the Xbox One. Windows 10 for the Raspberry Pi and instructions for setting up Windows 10 and Visual Studio 2015 for Windows Universal Platform can be found here. http://ms-iot.github.io/content/en-US/Downloads.htm Sitecore - Sitecore.Services.Client For the communication between the IoT application and Sitecore it makes perfect sense to use Web API. Luckily Sitecore has its own Web API based framework under the Sitecore.Services.Client (SSC) namespace. With Entity Service within Sitecore.Services.Client (SSC) all the authentication around access the rest end point is handled for us, along with model validation. The power in Entity Service comes where we can implement our own logic for the controller, we still have access to the full Sitecore API and in this case the xDB APIs. Creating the xDB Web API end point with Entity Service (SSC) The first thing we need for the kiosk application is to create a Entity Service controller and repository to expose and interact with data within Sitecore xDB. The first stage is to create our model we will expose on the Entity Service controller.Here we add all the properties from xDB we want to expose. This must implement EntityIdentity, this base class contains an ID, we will use this to store the xDB identifier for the user. Thanks to Jonathan Robbins and his xDB posts for working out some of this code. Next is our repository, here we will write the implementation code for working with xDB and the methods we want to expose over the API. The IRepository gives us the methods of our Entity Service API, so we can write the implementation for each of these methods. XdbFacetRepository is a class I have created for working with xDB, and can be seen below. The actual controller wires up the link between the Entity (Person), and the repository. Windows Universal Platform (Windows 10 IoT Core) Now we have created the Entity Service API that allows us to post into xDB, the next step is to created a Windows Universal Platform (UWP) that can capture the data and post to our Entity Service. As I mentioned earlier Windows Universal Platform apps are restricted to Windows 10 IoT and can run on all Windows 10 based platforms. Below is a screen shot of the kiosk application I created, it captures a users first name, last name and email address. This has been created using the designer within Visual Studio 2015. Windows Universal Application - Kiosk Application To get the form data into Sitecore xDB, we simply need to post to our Entity Service end point. We create a JSON string with our form data, here we are using the user's email address as the unique identifier. The JSON string can then be posted to our Entity Service end point. The authentication code to access the Entity Service isn't shown here for simplicity. I have written another blog on Sitecore.Services.Client authentication. Sitecore Services Client The below video is an example of the finished kiosk posting data into Sitecore's xDB. Up Next In the next post I will look at creating a custom facet and updating the facet from an IoT application. I will create a VisitedEvent facet and update this facet when a user completes the kiosk form. GitHub Source Full source code is available on GitHub. https://github.com/komainu85/WindowsIoTSitecoreSSC</summary></entry><entry><title type="html">Sitecore.Services.Client Authentication</title><link href="http://localhost:4000/entityservice/sitecore/sitecore.services.client/2016/01/14/sitecore-services-client-authentication.html" rel="alternate" type="text/html" title="Sitecore.Services.Client Authentication" /><published>2016-01-14T20:31:58+00:00</published><updated>2016-01-14T20:31:58+00:00</updated><id>http://localhost:4000/entityservice/sitecore/sitecore.services.client/2016/01/14/sitecore-services-client-authentication</id><content type="html" xml:base="http://localhost:4000/entityservice/sitecore/sitecore.services.client/2016/01/14/sitecore-services-client-authentication.html">&lt;p&gt;Requests to web services built upon the Sitecore.Services.Client framework need to be authenticated, in this post I will look at the authentication features built into Sitecore.Services.Client.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;HTTPS is required for calls to authentation services calls. As with the rest of the Sitecore framework SSC uses the ASP.net membership framework. When a authentation request is successful the .ASPXAUTH cookie is set in the response.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;For local testing make sure to generate a CA for your local self signed certificate. &lt;a href=&quot;http://www.asp.net/web-api/overview/security/working-with-ssl-in-web-api&quot;&gt;http://www.asp.net/web-api/overview/security/working-with-ssl-in-web-api&amp;nbsp;&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;Login&lt;/h2&gt;
&lt;p&gt;&lt;b&gt;Request&lt;/b&gt;&lt;br /&gt;
https://mikerobbins81u1/Sitecore/api/ssc/auth/login&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Body&lt;/b&gt;&lt;br /&gt;
Content-Type: application/json&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
{&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;domain&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;: &lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;sitecore&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;,&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;username&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;: &lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;admin&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;,&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;password&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;: &lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;b&lt;span class=&quot;ni&quot;&gt;&amp;amp;quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
}&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Response&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 response code&lt;/li&gt;
&lt;li&gt;.ASPXAUTH cookie set&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Logout&lt;/h2&gt;
&lt;p&gt;&lt;b&gt;Request&lt;/b&gt;&lt;br /&gt;
https://mikerobbins81u1/Sitecore/api/ssc/auth/logout&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Response&lt;/b&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;200 response code&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Authentication Examples&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Console Application&lt;/b&gt;&lt;br /&gt;
Below is a great example from &lt;a href=&quot;https://twitter.com/herskinduk&quot;&gt;Kern&lt;/a&gt; of authentication again SSC within a C# console application.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/herskinduk/918a2c3ab4a248b380e7.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Windows 10 IoT (Universal Windows Application)&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/103fb60107c542d56a49.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Sitecore SPEAK&lt;/b&gt;&lt;br /&gt;
As Sitecore.Services.Client authentication is based upon asp.net membership and sets a .ASPXAUTH cookie, the same authentication as the Sitecore client and therefore Sitecore SPEAK. This means you are already authenticated, as you'll already be authenticated by having the .ASPXAUTH cookie set by the Sitecore login screen.&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="Authentication" /><category term="Sitecore 7.5" /><category term="Sitecore 8" /><category term="Sitecore.Services.Client" /><category term="SSC" /><summary type="html">Requests to web services built upon the Sitecore.Services.Client framework need to be authenticated, in this post I will look at the authentication features built into Sitecore.Services.Client. HTTPS is required for calls to authentation services calls. As with the rest of the Sitecore framework SSC uses the ASP.net membership framework. When a authentation request is successful the .ASPXAUTH cookie is set in the response. For local testing make sure to generate a CA for your local self signed certificate. http://www.asp.net/web-api/overview/security/working-with-ssl-in-web-api&amp;nbsp; Login Request https://mikerobbins81u1/Sitecore/api/ssc/auth/login Body Content-Type: application/json &amp;lt;br /&amp;gt; {&amp;lt;br /&amp;gt; &amp;amp;quot;domain&amp;amp;quot;: &amp;amp;quot;sitecore&amp;amp;quot;,&amp;lt;br /&amp;gt; &amp;amp;quot;username&amp;amp;quot;: &amp;amp;quot;admin&amp;amp;quot;,&amp;lt;br /&amp;gt; &amp;amp;quot;password&amp;amp;quot;: &amp;amp;quot;b&amp;amp;quot;&amp;lt;br /&amp;gt; }&amp;lt;br /&amp;gt; Response 200 response code .ASPXAUTH cookie set Logout Request https://mikerobbins81u1/Sitecore/api/ssc/auth/logout Response 200 response code Authentication Examples Console Application Below is a great example from Kern of authentication again SSC within a C# console application. Windows 10 IoT (Universal Windows Application) Sitecore SPEAK As Sitecore.Services.Client authentication is based upon asp.net membership and sets a .ASPXAUTH cookie, the same authentication as the Sitecore client and therefore Sitecore SPEAK. This means you are already authenticated, as you'll already be authenticated by having the .ASPXAUTH cookie set by the Sitecore login screen.</summary></entry><entry><title type="html">Sitecore Client Logging with JSNLog In Sitecore 8.1</title><link href="http://localhost:4000/developer/sitecore/2015/12/02/sitecore-client-logging-with-jsnlog-in-sitecore-8-1.html" rel="alternate" type="text/html" title="Sitecore Client Logging with JSNLog In Sitecore 8.1" /><published>2015-12-02T19:41:18+00:00</published><updated>2015-12-02T19:41:18+00:00</updated><id>http://localhost:4000/developer/sitecore/2015/12/02/sitecore-client-logging-with-jsnlog-in-sitecore-8-1</id><content type="html" xml:base="http://localhost:4000/developer/sitecore/2015/12/02/sitecore-client-logging-with-jsnlog-in-sitecore-8-1.html">&lt;p&gt;With Sitecore 8.1, support has been added to log client side events. The new logging framework is built upon the standard Sitecore logging framework (which uses Log4net), allowing client side events to be logged back to the data/log folder on the delivery server.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Under the hood, Sitecore client logging uses JSNLog which has been wrapped to allow Sitecore to configure it via a patch and to make use of the existing Log4net logging.&lt;/p&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;All configuration for client logging is contained within Sitecore.JSNLog.config within App_Data/Include.&lt;/p&gt;
&lt;h3&gt;jsnlog element&lt;/h3&gt;
&lt;p&gt;&lt;b&gt;Enabled&lt;/b&gt; - Allows Client logging to be enabled. Beware disabling this option as the Sitecore CMS uses client logging for its diagnostics. You may need this option on if you need to raise support tickets.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;productionLibraryPath &lt;/b&gt;- Allows you to change the path at which the jsnlog JavaScript is located. This is useful when the Sitecore directory isn't deployed on a delivery server.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;serverSideMessageFormat&lt;/b&gt; - Here you can specify the format of the error message that is stored within the log. Above in the comments in the config file are a list of all the varibles. These can be seen below.&lt;/p&gt;
&lt;h3&gt;ajaxAppender&lt;/h3&gt;
&lt;p&gt;This is the appender thats used to write the errors to the Sitecore data log folder. Here we can specify the error level.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;level &lt;/b&gt;- Here you can specify what level of logging is used (DEBUG|ERROR|INFO)&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/caaa5c77df12d31c4797.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;h2&gt;Using Client Logging In Your Website&lt;/h2&gt;
&lt;p&gt;This is simple, logging will work if the JSNLog JavaScript has been rendering into the head of your HTML, this is done via a Sitecore helper. The helper within the Diagnostics namespace that renders out the JavaScript pulling the required varibles into the JavaScript.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/42ad72cc322d841e9a70.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Logging is now enabled, Sitecore will capture all unhandled JavaScript errors and log them in the log folder on the server. You can also write to the log via the JSNLog API &quot;JL()&quot; as below.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/1c9145d6bddff420acf9.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;By default when using client logging you will see a JSON object being displayed in your browser's console every time you write to the log. You can see this below&lt;/p&gt;
&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;1280&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/12/img_0023.png&quot;&gt;&lt;img class=&quot;size-custom&quot; title=&quot;Client JavaScript Error Logging&quot; src=&quot;/assets/img_0023.png&quot; alt=&quot;Client JavaScript Error Logging&quot; width=&quot;1280&quot; height=&quot;982&quot; /&gt;&lt;/a&gt; Client JavaScript Error Logging&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;This functionality can be switched off, so logs are written but the log isn't displayed in the console window.&lt;/p&gt;
&lt;p&gt;Within the Sitecore.JSNLog.config, there is an appender for the console called - consoleAppender. This is enabled by the logger appender element that accepts a comma seperate list of appenders. Removing the consoleAppender from this list disabled the console appender.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/42347beae5ab1201b94b.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="Client Logging" /><category term="ClientLog" /><category term="JSNLog" /><category term="Logging" /><category term="Sitecore 8.1" /><summary type="html">With Sitecore 8.1, support has been added to log client side events. The new logging framework is built upon the standard Sitecore logging framework (which uses Log4net), allowing client side events to be logged back to the data/log folder on the delivery server. Under the hood, Sitecore client logging uses JSNLog which has been wrapped to allow Sitecore to configure it via a patch and to make use of the existing Log4net logging. Configuration All configuration for client logging is contained within Sitecore.JSNLog.config within App_Data/Include. jsnlog element Enabled - Allows Client logging to be enabled. Beware disabling this option as the Sitecore CMS uses client logging for its diagnostics. You may need this option on if you need to raise support tickets. productionLibraryPath - Allows you to change the path at which the jsnlog JavaScript is located. This is useful when the Sitecore directory isn't deployed on a delivery server. serverSideMessageFormat - Here you can specify the format of the error message that is stored within the log. Above in the comments in the config file are a list of all the varibles. These can be seen below. ajaxAppender This is the appender thats used to write the errors to the Sitecore data log folder. Here we can specify the error level. level - Here you can specify what level of logging is used (DEBUG|ERROR|INFO) Using Client Logging In Your Website This is simple, logging will work if the JSNLog JavaScript has been rendering into the head of your HTML, this is done via a Sitecore helper. The helper within the Diagnostics namespace that renders out the JavaScript pulling the required varibles into the JavaScript. Logging is now enabled, Sitecore will capture all unhandled JavaScript errors and log them in the log folder on the server. You can also write to the log via the JSNLog API &quot;JL()&quot; as below. By default when using client logging you will see a JSON object being displayed in your browser's console every time you write to the log. You can see this below [caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;1280&quot;] Client JavaScript Error Logging &amp;nbsp; This functionality can be switched off, so logs are written but the log isn't displayed in the console window. Within the Sitecore.JSNLog.config, there is an appender for the console called - consoleAppender. This is enabled by the logger appender element that accepts a comma seperate list of appenders. Removing the consoleAppender from this list disabled the console appender.</summary></entry><entry><title type="html">getFieldLabel Pipeline in Sitecore 8.1</title><link href="http://localhost:4000/content%20editor/sitecore/2015/10/23/getfieldlabel-pipeline-in-sitecore-8-1.html" rel="alternate" type="text/html" title="getFieldLabel Pipeline in Sitecore 8.1" /><published>2015-10-23T14:18:04+01:00</published><updated>2015-10-23T14:18:04+01:00</updated><id>http://localhost:4000/content%20editor/sitecore/2015/10/23/getfieldlabel-pipeline-in-sitecore-8-1</id><content type="html" xml:base="http://localhost:4000/content%20editor/sitecore/2015/10/23/getfieldlabel-pipeline-in-sitecore-8-1.html">&lt;p&gt;With the release of Sitecore 8.1 a new Pipeline called &lt;strong&gt;getFieldLabel &lt;/strong&gt;was added. This new pipeline allows you to inject code that can append or alter the label of a field within the Content Editor.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;The first thing to notice is that the pipeline accepts a &lt;strong&gt;&lt;span class=&quot;pl-en&quot;&gt;GetFieldLabelArgs &lt;/span&gt;&lt;/strong&gt;&lt;span class=&quot;pl-en&quot;&gt;class for pipeline. This contains the field in question and the result. The result is a string of what will be appended to the label.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/26850da3533da2041ae3.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Within the process method you have access to the field that your updating, the result string can be appended to by your code. This is what is displayed in the Content Editor above the field, it can be text or HTML.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/d360b49f8fd4632b1fd9.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/3177125ddd878240ae99.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Below is an example of what gets rendered in the Content Editor.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_1002&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/10/getfieldlabelpipeline.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-1002&quot; src=&quot;/assets/getfieldlabelpipeline.png&quot; alt=&quot;GetFieldLabelPipeline&quot; width=&quot;300&quot; height=&quot;37&quot; /&gt;&lt;/a&gt; GetFieldLabelPipeline&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="content editor" /><category term="getFieldLabel" /><category term="Pipelines" /><category term="Sitecore 8.1" /><summary type="html">With the release of Sitecore 8.1 a new Pipeline called getFieldLabel was added. This new pipeline allows you to inject code that can append or alter the label of a field within the Content Editor. The first thing to notice is that the pipeline accepts a GetFieldLabelArgs class for pipeline. This contains the field in question and the result. The result is a string of what will be appended to the label. Within the process method you have access to the field that your updating, the result string can be appended to by your code. This is what is displayed in the Content Editor above the field, it can be text or HTML. Below is an example of what gets rendered in the Content Editor. [caption id=&quot;attachment_1002&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] GetFieldLabelPipeline</summary></entry><entry><title type="html">Sitecore SPEAK 2.0 Component vs SPEAK 1.1</title><link href="http://localhost:4000/sitecore/speak/2015/10/20/sitecore-speak-2-0-component-vs-speak-1-1.html" rel="alternate" type="text/html" title="Sitecore SPEAK 2.0 Component vs SPEAK 1.1" /><published>2015-10-20T14:03:06+01:00</published><updated>2015-10-20T14:03:06+01:00</updated><id>http://localhost:4000/sitecore/speak/2015/10/20/sitecore-speak-2-0-component-vs-speak-1-1</id><content type="html" xml:base="http://localhost:4000/sitecore/speak/2015/10/20/sitecore-speak-2-0-component-vs-speak-1-1.html">&lt;p&gt;With Sitecore 8.1 we get access to a brand new version of SPEAK, the shiny SPEAK 2.0.&lt;/p&gt;
&lt;p&gt;In this blog post we will look at creating a new SPEAK component using the 2.0 framework. We will compare the same SPEAK component built against version 1.0 and 2.0 to see the differences the new framework makes to development.&lt;!--more--&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Its worth noting that SPEAK 1.1 can still be used within Sitecore 8.1. But a SPEAK application has to be fully built against a single SPEAK version, you can't mix components of different versions.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2&gt;Enabling SPEAK 2.0 in a SPEAK application&lt;/h2&gt;
&lt;p&gt;To use the new version of SPEAK, within the PageCode of your SPEAK application the SpeakCoreVersion property has to be set to Speak Core 2-0. This setting will load in the SPEAK core javascript files for SPEAK 2.0 into your application.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_930&quot; align=&quot;aligncenter&quot; width=&quot;225&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/10/speak-page-code.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-930&quot; src=&quot;/assets/speak-page-code.png?w=225&quot; alt=&quot;SPEAK 2.0 Page Code&quot; width=&quot;225&quot; height=&quot;300&quot; /&gt;&lt;/a&gt; SPEAK 2.0 Page Code&lt;/p&gt;
&lt;p&gt;All SPEAK 2.0 components within the version 2 folder in the Business Component Library and sit alongside the version 1 files. &quot;sitecore\shell\client\Business Component Library\version 2\Layouts\Renderings&quot;.&lt;/p&gt;
&lt;p&gt;Within Sitecore Rocks, SPEAK 2.0 components can be identified by the SPEAK Core 2-0 tag in the add renderings dialog.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_939&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/10/speak-2-0-components.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-939&quot; src=&quot;/assets/speak-2-0-components.png&quot; alt=&quot;SPEAK 2.0 Components&quot; width=&quot;300&quot; height=&quot;240&quot; /&gt;&lt;/a&gt; SPEAK 2.0 Components&lt;/p&gt;
&lt;h2&gt;Custom SPEAK components&lt;/h2&gt;
&lt;p&gt;So onto the main subject of this blog post, creating a new custom SPEAK component with SPEAK 2.0. The code samples below are of a Rich Text Editor component built against both SPEAK 1.1 and SPEAK 2.0.&lt;/p&gt;
&lt;h3&gt;SPEAK 1.1 Component&lt;/h3&gt;
&lt;h4&gt;Cshtml File&lt;/h4&gt;
&lt;p&gt;This is when the HTML is defined and properties from our parameter template for component in Sitecore are mapped into attributes on our control.&lt;/p&gt;
&lt;p&gt;In this example we are getting parameters such as the height from the parameter template in Sitecore using rendering.GetString(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Height&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;Height&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;pl-k&quot;&gt;string&lt;/span&gt;.Empty); and setting the value into a data attribute rendering.Attributes[&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;data-sc-height&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;].&lt;/p&gt;
&lt;h4&gt;Javascript File&lt;/h4&gt;
&lt;p&gt;We firstly use Require.js to import our JavaScript dependencies.&lt;/p&gt;
&lt;p&gt;After the standard SPEAK component framework mark-up, we initialize the model for the component, setting each of its properties to null.&lt;/p&gt;
&lt;p&gt;In the view initialize function we need to set each model property from the data attribute we created in the cshtml.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/a7bd9bd4cc56baceec49.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;h3&gt;SPEAK 2.0 Component&lt;/h3&gt;
&lt;p&gt;With SPEAK 2.0 much of the heavy lifting and plumbing code is handled by Sitecore SPEAK, we can concentrate more on our component logic.&lt;/p&gt;
&lt;h4&gt;Model&lt;/h4&gt;
&lt;p&gt;The biggest change between 1.1 and 2.0 is the inclusion of a server side model. This model represents our rendering parameters for our component. We inherit from the CollectionBaseRenderingModel base class and create a property for each of our rendering parameters, matching their name.&lt;/p&gt;
&lt;p&gt;Within Sitecore Rocks for our component we can specific the class in the model field.&lt;/p&gt;
&lt;h4&gt;Cshtml File&lt;/h4&gt;
&lt;p&gt;As you can see in the Cshtml file it is much cleaner. Sitecore SPEAK is handling all the plumbing between our parameter template and our model.&lt;/p&gt;
&lt;p&gt;We simply need to specify our @model to our model class. All properties will be populated by Sitecore at runtime.&lt;/p&gt;
&lt;p&gt;We can require in our JavaScript for the component. Here I'm removing the standard location that Sitecore looks for my JavaScript, and re-adding the reference in a custom location. I do this not to clash with Sitecore default components.&lt;/p&gt;
&lt;h4&gt;JavaScript File&lt;/h4&gt;
&lt;p&gt;With the JavaScript code file the syntax has changed quite a bit. Again Sitecore SPEAK is handling a lot of the plumbing code for us. We no longer need to wire up each of the model properties ourselves. Sitecore will automatically populate each property for us.&lt;/p&gt;
&lt;p&gt;The way properties are also accessed in a different way. In SPEAK 1.1 we had to access properties via the view model E.g. &lt;span class=&quot;pl-v&quot;&gt;this&lt;/span&gt;.model.viewModel.&lt;span class=&quot;pl-c1&quot;&gt;height&lt;/span&gt;(). In SPEAK 2.0 this has been simplified to this.Height&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_957&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/10/speak-model.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-957&quot; src=&quot;/assets/speak-model.png&quot; alt=&quot;SPEAK 2.0 Model&quot; width=&quot;300&quot; height=&quot;216&quot; /&gt;&lt;/a&gt; SPEAK 2.0 Model&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/ad345ec872d3d0390241.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="Sitecore 8.1" /><category term="Sitecore SPEAK" /><category term="Sitecore SPEAK 2.0" /><category term="SPEAK 2.0" /><summary type="html">With Sitecore 8.1 we get access to a brand new version of SPEAK, the shiny SPEAK 2.0. In this blog post we will look at creating a new SPEAK component using the 2.0 framework. We will compare the same SPEAK component built against version 1.0 and 2.0 to see the differences the new framework makes to development. Its worth noting that SPEAK 1.1 can still be used within Sitecore 8.1. But a SPEAK application has to be fully built against a single SPEAK version, you can't mix components of different versions. Enabling SPEAK 2.0 in a SPEAK application To use the new version of SPEAK, within the PageCode of your SPEAK application the SpeakCoreVersion property has to be set to Speak Core 2-0. This setting will load in the SPEAK core javascript files for SPEAK 2.0 into your application. [caption id=&quot;attachment_930&quot; align=&quot;aligncenter&quot; width=&quot;225&quot;] SPEAK 2.0 Page Code All SPEAK 2.0 components within the version 2 folder in the Business Component Library and sit alongside the version 1 files. &quot;sitecore\shell\client\Business Component Library\version 2\Layouts\Renderings&quot;. Within Sitecore Rocks, SPEAK 2.0 components can be identified by the SPEAK Core 2-0 tag in the add renderings dialog. [caption id=&quot;attachment_939&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] SPEAK 2.0 Components Custom SPEAK components So onto the main subject of this blog post, creating a new custom SPEAK component with SPEAK 2.0. The code samples below are of a Rich Text Editor component built against both SPEAK 1.1 and SPEAK 2.0. SPEAK 1.1 Component Cshtml File This is when the HTML is defined and properties from our parameter template for component in Sitecore are mapped into attributes on our control. In this example we are getting parameters such as the height from the parameter template in Sitecore using rendering.GetString(&quot;Height&quot;, &quot;Height&quot;, string.Empty); and setting the value into a data attribute rendering.Attributes[&quot;data-sc-height&quot;]. Javascript File We firstly use Require.js to import our JavaScript dependencies. After the standard SPEAK component framework mark-up, we initialize the model for the component, setting each of its properties to null. In the view initialize function we need to set each model property from the data attribute we created in the cshtml. SPEAK 2.0 Component With SPEAK 2.0 much of the heavy lifting and plumbing code is handled by Sitecore SPEAK, we can concentrate more on our component logic. Model The biggest change between 1.1 and 2.0 is the inclusion of a server side model. This model represents our rendering parameters for our component. We inherit from the CollectionBaseRenderingModel base class and create a property for each of our rendering parameters, matching their name. Within Sitecore Rocks for our component we can specific the class in the model field. Cshtml File As you can see in the Cshtml file it is much cleaner. Sitecore SPEAK is handling all the plumbing between our parameter template and our model. We simply need to specify our @model to our model class. All properties will be populated by Sitecore at runtime. We can require in our JavaScript for the component. Here I'm removing the standard location that Sitecore looks for my JavaScript, and re-adding the reference in a custom location. I do this not to clash with Sitecore default components. JavaScript File With the JavaScript code file the syntax has changed quite a bit. Again Sitecore SPEAK is handling a lot of the plumbing code for us. We no longer need to wire up each of the model properties ourselves. Sitecore will automatically populate each property for us. The way properties are also accessed in a different way. In SPEAK 1.1 we had to access properties via the view model E.g. this.model.viewModel.height(). In SPEAK 2.0 this has been simplified to this.Height [caption id=&quot;attachment_957&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] SPEAK 2.0 Model</summary></entry><entry><title type="html">Sitecore SPEAK Sitecore.app undefined in Sitecore 7.5 and Sitecore 8</title><link href="http://localhost:4000/sitecore/speak/2015/10/19/sitecore-speak-sitecore-app-null-in-sitecore-7-5-and-sitecore-8.html" rel="alternate" type="text/html" title="Sitecore SPEAK Sitecore.app undefined in Sitecore 7.5 and Sitecore 8" /><published>2015-10-19T09:07:28+01:00</published><updated>2015-10-19T09:07:28+01:00</updated><id>http://localhost:4000/sitecore/speak/2015/10/19/sitecore-speak-sitecore-app-null-in-sitecore-7-5-and-sitecore-8</id><content type="html" xml:base="http://localhost:4000/sitecore/speak/2015/10/19/sitecore-speak-sitecore-app-null-in-sitecore-7-5-and-sitecore-8.html">&lt;p&gt;Very quick post post, I know this has been catching a number of people out. Such as this Stack Overflow question. &lt;a href=&quot;http://stackoverflow.com/questions/33020451/sitecore-speak-and-javascript/33023142#33023142&quot;&gt;http://stackoverflow.com/questions/33020451/sitecore-speak-and-javascript/33023142#33023142&lt;/a&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;When debugging Sitecore SPEAK in Sitecore 7.x (query string ?sc_debug=1)  you could access and debug your SPEAK application in your console browser via Sitecore.app. When trying this in Sitecore 7.5 and 8 you will get &quot;undefined&quot; returned.&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;In Sitecore 7.5 and 8.x Sitecore.app has been moved. The new namespace is Sitecore.Speak.app.&lt;/p&gt;&lt;/blockquote&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="JavaScript" /><category term="PageCode" /><category term="Sitecore 7.5" /><category term="Sitecore 8" /><category term="Sitecore SPEAK" /><summary type="html">Very quick post post, I know this has been catching a number of people out. Such as this Stack Overflow question. http://stackoverflow.com/questions/33020451/sitecore-speak-and-javascript/33023142#33023142 When debugging Sitecore SPEAK in Sitecore 7.x (query string ?sc_debug=1)  you could access and debug your SPEAK application in your console browser via Sitecore.app. When trying this in Sitecore 7.5 and 8 you will get &quot;undefined&quot; returned. In Sitecore 7.5 and 8.x Sitecore.app has been moved. The new namespace is Sitecore.Speak.app.</summary></entry><entry><title type="html">Sitecore.Services.Client / Entity Service Allowed Controllers</title><link href="http://localhost:4000/entityservice/sitecore/sitecore.services.client/2015/10/16/sitecore-services-client-entity-service-allowed-controllers.html" rel="alternate" type="text/html" title="Sitecore.Services.Client / Entity Service Allowed Controllers" /><published>2015-10-16T13:22:16+01:00</published><updated>2015-10-16T13:22:16+01:00</updated><id>http://localhost:4000/entityservice/sitecore/sitecore.services.client/2015/10/16/sitecore-services-client-entity-service-allowed-controllers</id><content type="html" xml:base="http://localhost:4000/entityservice/sitecore/sitecore.services.client/2015/10/16/sitecore-services-client-entity-service-allowed-controllers.html">&lt;p&gt;By default any Entity Service controllers you create abide by the &lt;strong&gt;Sitecore.Services.SecurityPolicy &lt;/strong&gt;setting within the Sitecore.Services.Client.config. By default this is set to &lt;strong&gt;Sitecore.Services.Infrastructure.Web.Http.Security.ServicesLocalOnlyPolicy &lt;/strong&gt;making the service safe and controllers only availably locally. This will cause issues if you call your controller in a live environment outside of the local environment as it wont be accessible.&lt;/p&gt;
&lt;h2&gt;Allowed Controllers&lt;/h2&gt;
&lt;p&gt;You can patch this setting to enable all controllers, but this is not a recommended practice, as this will open all controller endpoints to the world.&lt;/p&gt;
&lt;p&gt;Instead SSC has the idea of &lt;b&gt;allowedControllers.&lt;/b&gt; This section within the Sitecore.Services.Client.config allow you to patch in controllers that are exempt from the &lt;strong&gt;ServicesLocalOnlyPolicy &lt;/strong&gt;setting. This section allows fine control over exactly which controllers are available externally.&lt;/p&gt;
&lt;p&gt;Using the allowed controllers setting doesn't mean you have to sacrifice all security on your controller. After patching in your controllers into the &lt;strong&gt;allowedControllers &lt;/strong&gt;section, you can apply standard authentication filters or Cors to your controller.&lt;/p&gt;
&lt;p&gt;Below is an example of a patch file that patches a custom controller into the &lt;strong&gt;allowedControllers &lt;/strong&gt;section. You will also notice many of the Sitecore modules using this allowedControllers section such as xDB and XFM (Shown at the bottom of the page).&lt;/p&gt;
&lt;p&gt;Huge thanks to &lt;a href=&quot;https://twitter.com/KevinObee&quot;&gt;@KevinObee&lt;/a&gt; for explaining lots of how SSC works.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/20012af8a887a0f8d777.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;
&lt;p&gt;Sitecore FXM using allowedControllers&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/cb746817db4f28157103.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="developer" /><category term="Entity Service" /><category term="Sitecore 7.5" /><category term="Sitecore 8" /><category term="Sitecore.Services.Client" /><category term="SSC" /><summary type="html">By default any Entity Service controllers you create abide by the Sitecore.Services.SecurityPolicy setting within the Sitecore.Services.Client.config. By default this is set to Sitecore.Services.Infrastructure.Web.Http.Security.ServicesLocalOnlyPolicy making the service safe and controllers only availably locally. This will cause issues if you call your controller in a live environment outside of the local environment as it wont be accessible. Allowed Controllers You can patch this setting to enable all controllers, but this is not a recommended practice, as this will open all controller endpoints to the world. Instead SSC has the idea of allowedControllers. This section within the Sitecore.Services.Client.config allow you to patch in controllers that are exempt from the ServicesLocalOnlyPolicy setting. This section allows fine control over exactly which controllers are available externally. Using the allowed controllers setting doesn't mean you have to sacrifice all security on your controller. After patching in your controllers into the allowedControllers section, you can apply standard authentication filters or Cors to your controller. Below is an example of a patch file that patches a custom controller into the allowedControllers section. You will also notice many of the Sitecore modules using this allowedControllers section such as xDB and XFM (Shown at the bottom of the page). Huge thanks to @KevinObee for explaining lots of how SSC works. Sitecore FXM using allowedControllers</summary></entry><entry><title type="html">Sitecore Content Search Computed Field Pass Custom Variables</title><link href="http://localhost:4000/content%20search/sitecore/2015/09/10/sitecore-content-search-computed-field-pass-custom-variables.html" rel="alternate" type="text/html" title="Sitecore Content Search Computed Field Pass Custom Variables" /><published>2015-09-10T13:04:41+01:00</published><updated>2015-09-10T13:04:41+01:00</updated><id>http://localhost:4000/content%20search/sitecore/2015/09/10/sitecore-content-search-computed-field-pass-custom-variables</id><content type="html" xml:base="http://localhost:4000/content%20search/sitecore/2015/09/10/sitecore-content-search-computed-field-pass-custom-variables.html">&lt;p&gt;One requirement of Content Search i've required recently, is the ability to pass in custom variables from the computed field config element. I needed this so multiple sites can use the same computed fields, but inject settings unique to that site. For example passing in the site name to generate site specific urls.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;Out of the box Sitecore allows you to specify a fieldName in the computed field and this populates a property within you computed field class. This is the feature I wanted to extend to pass in my own properties into the class.&lt;/p&gt;
&lt;p&gt;So below is an example computed field class that uses this method. The computed field generates url's for items using the LinkManager class but takes in the site context from the computed field config.&lt;/p&gt;
&lt;p&gt;The class implements the AbstractComputedIndexField base class. On the constructor, the &lt;span class=&quot;pl-k&quot;&gt;XmlNode of the computed field is passed in and using  XmlUtil.GetAttribute(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;siteName&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;, configurationNode); we can read XML elements of the config and populate our properties in our computed field.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I'm tapping into the standard urllink property within the index configuration, this means when inheriting from SearchResultItem base class the property Url is populated. This is normally null by default, &lt;a href=&quot;http://www.ehabelgindy.com/sitecore-7-solr-why-searchresultitem-url-is-always-null/&quot;&gt;Ehab ElGindy&lt;/a&gt; also talks about the Url being null.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/3a6efad20ab1b2a56385.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="ComputedFields" /><category term="developer" /><category term="Sitecore 7" /><category term="Sitecore 8" /><summary type="html">One requirement of Content Search i've required recently, is the ability to pass in custom variables from the computed field config element. I needed this so multiple sites can use the same computed fields, but inject settings unique to that site. For example passing in the site name to generate site specific urls. Out of the box Sitecore allows you to specify a fieldName in the computed field and this populates a property within you computed field class. This is the feature I wanted to extend to pass in my own properties into the class. So below is an example computed field class that uses this method. The computed field generates url's for items using the LinkManager class but takes in the site context from the computed field config. The class implements the AbstractComputedIndexField base class. On the constructor, the XmlNode of the computed field is passed in and using  XmlUtil.GetAttribute(&quot;siteName&quot;, configurationNode); we can read XML elements of the config and populate our properties in our computed field. I'm tapping into the standard urllink property within the index configuration, this means when inheriting from SearchResultItem base class the property Url is populated. This is normally null by default, Ehab ElGindy also talks about the Url being null.</summary></entry><entry><title type="html">Sitecore SPEAK Rich Text Editor</title><link href="http://localhost:4000/sitecore/speak/2015/08/11/sitecore-speak-rich-text-editor.html" rel="alternate" type="text/html" title="Sitecore SPEAK Rich Text Editor" /><published>2015-08-11T14:26:22+01:00</published><updated>2015-08-11T14:26:22+01:00</updated><id>http://localhost:4000/sitecore/speak/2015/08/11/sitecore-speak-rich-text-editor</id><content type="html" xml:base="http://localhost:4000/sitecore/speak/2015/08/11/sitecore-speak-rich-text-editor.html">&lt;p&gt;One of the features I think has been missing from Sitecore SPEAK is a Rich Text component. This blog post is a custom Rich Text Editor I have created for Sitecore SPEAK, The underlying Rich Text Editor is provided by &lt;a href=&quot;http://www.tinymce.com&quot;&gt;Tiny MCE&lt;/a&gt;.&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_879&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/08/screenshot1.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-879&quot; src=&quot;/assets/screenshot1.png&quot; alt=&quot;Sitecore SPEAK Rich Text Editor&quot; width=&quot;300&quot; height=&quot;162&quot; /&gt;&lt;/a&gt; Sitecore SPEAK Rich Text Editor&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_903&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/08/edittor.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-903&quot; src=&quot;/assets/edittor.png&quot; alt=&quot;Toolbar&quot; width=&quot;300&quot; height=&quot;163&quot; /&gt;&lt;/a&gt; Toolbar&lt;/p&gt;
&lt;h2&gt;Configuration&lt;/h2&gt;
&lt;p&gt;Once the Sitecore package has been installed (Releases at the end of this page), the component is ready to be used in SPEAK applications. The Rich Text Editor will then appear when you insert a rendering into the design layout of your SPEAK application.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_888&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/08/renderings.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-888&quot; src=&quot;/assets/renderings.png&quot; alt=&quot;Rich Text Editor Rendering&quot; width=&quot;300&quot; height=&quot;200&quot; /&gt;&lt;/a&gt; Rich Text Editor Rendering&lt;/p&gt;
&lt;p&gt;The parameter template of the Rich Text Editor allows you to set the ID, and both the height and width of the rendered editor. The text property will get bound to the html value within the editor, you can also set an initial value for the html in the editor.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_889&quot; align=&quot;aligncenter&quot; width=&quot;281&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/08/params.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-889&quot; src=&quot;/assets/params.png?w=281&quot; alt=&quot;Rendering Parameters&quot; width=&quot;281&quot; height=&quot;300&quot; /&gt;&lt;/a&gt; Rendering Parameters&lt;/p&gt;
&lt;p&gt;Multiple Rich Text Editors on a single SPEAK form is supported, ensure each RTE has an ID set and that they are all unique.&lt;/p&gt;
&lt;p&gt;[caption id=&quot;attachment_884&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;]&lt;a href=&quot;https://mikerobbinssitecore.files.wordpress.com/2015/08/screenshot2.png&quot;&gt;&lt;img class=&quot;size-medium wp-image-884&quot; src=&quot;/assets/screenshot2.png&quot; alt=&quot;Multiple Rich Text Editors&quot; width=&quot;300&quot; height=&quot;166&quot; /&gt;&lt;/a&gt; Multiple Rich Text Editors&lt;/p&gt;
&lt;h2&gt;Plugins&lt;/h2&gt;
&lt;p&gt;Tiny MCE Plugings can be added to the RTE, in the rendering parameters there is a field called plugins. This field can take a string of space seperate plugin names to enable on the RTE. For available plugins please see &lt;a href=&quot;http://www.tinymce.com/wiki.php/Plugins&quot;&gt;http://www.tinymce.com/wiki.php/Plugins&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Coding Against The RTE&lt;/h2&gt;
&lt;p&gt;While debugging the SPEAK application within the console of your browser, you can access the Rich Text Editor via the below. (Where RichText1 is the ID of your component)&lt;/p&gt;
&lt;pre&gt;Sitecore.Speak.app.RichText1.viewModel&lt;/pre&gt;
&lt;p&gt;The text() of the viewModel has a get / set where you can read and write HTML in the Rich Text Editor. e.g. this.RichText1.viewModel.text(&quot;&lt;p&gt;Some text&lt;/p&gt;&quot;)&lt;/p&gt;
&lt;p&gt;You can get access to the underlying Rich Text Editor via:&lt;/p&gt;
&lt;pre&gt;tinyMCE.get(&quot;RichTextEditorID&quot;)&lt;/pre&gt;
&lt;h2&gt;Compatibility&lt;/h2&gt;
&lt;p&gt;The component was built and tested on Sitecore 8. However as the component is built on SPEAK 1.1 the component should work on Sitecore 7.2- 7.5. I will do some testing to ensure the component works correctly on Sitecore 7.x.&lt;/p&gt;
&lt;h2&gt;Releases (Sitecore Package)&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/komainu85/MikeRobbinsSPEAKRichTextEditor/releases&quot;&gt;https://github.com/komainu85/MikeRobbinsSPEAKRichTextEditor/releases&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Source On GitHub&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/komainu85/MikeRobbinsSPEAKRichTextEditor&quot;&gt;https://github.com/sobek85/MikeRobbinsSPEAKRichTextEditor&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="Custom component" /><category term="Rich Text Editor" /><category term="Sitecore 7.1" /><category term="Sitecore 7.2" /><category term="Sitecore 7.5" /><category term="Sitecore 8" /><category term="Sitecore SPEAK" /><summary type="html">One of the features I think has been missing from Sitecore SPEAK is a Rich Text component. This blog post is a custom Rich Text Editor I have created for Sitecore SPEAK, The underlying Rich Text Editor is provided by Tiny MCE. [caption id=&quot;attachment_879&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] Sitecore SPEAK Rich Text Editor [caption id=&quot;attachment_903&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] Toolbar Configuration Once the Sitecore package has been installed (Releases at the end of this page), the component is ready to be used in SPEAK applications. The Rich Text Editor will then appear when you insert a rendering into the design layout of your SPEAK application. [caption id=&quot;attachment_888&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] Rich Text Editor Rendering The parameter template of the Rich Text Editor allows you to set the ID, and both the height and width of the rendered editor. The text property will get bound to the html value within the editor, you can also set an initial value for the html in the editor. [caption id=&quot;attachment_889&quot; align=&quot;aligncenter&quot; width=&quot;281&quot;] Rendering Parameters Multiple Rich Text Editors on a single SPEAK form is supported, ensure each RTE has an ID set and that they are all unique. [caption id=&quot;attachment_884&quot; align=&quot;aligncenter&quot; width=&quot;300&quot;] Multiple Rich Text Editors Plugins Tiny MCE Plugings can be added to the RTE, in the rendering parameters there is a field called plugins. This field can take a string of space seperate plugin names to enable on the RTE. For available plugins please see http://www.tinymce.com/wiki.php/Plugins. Coding Against The RTE While debugging the SPEAK application within the console of your browser, you can access the Rich Text Editor via the below. (Where RichText1 is the ID of your component) Sitecore.Speak.app.RichText1.viewModel The text() of the viewModel has a get / set where you can read and write HTML in the Rich Text Editor. e.g. this.RichText1.viewModel.text(&quot;Some text&quot;) You can get access to the underlying Rich Text Editor via: tinyMCE.get(&quot;RichTextEditorID&quot;) Compatibility The component was built and tested on Sitecore 8. However as the component is built on SPEAK 1.1 the component should work on Sitecore 7.2- 7.5. I will do some testing to ensure the component works correctly on Sitecore 7.x. Releases (Sitecore Package) https://github.com/komainu85/MikeRobbinsSPEAKRichTextEditor/releases Source On GitHub https://github.com/sobek85/MikeRobbinsSPEAKRichTextEditor</summary></entry><entry><title type="html">Sitecore Razor / Glass Attribute Helper Methods Fluent API</title><link href="http://localhost:4000/developer/glass/sitecore/2015/07/29/sitecore-razor-glass-attribute-helper-methods-fluent-api.html" rel="alternate" type="text/html" title="Sitecore Razor / Glass Attribute Helper Methods Fluent API" /><published>2015-07-29T14:05:19+01:00</published><updated>2015-07-29T14:05:19+01:00</updated><id>http://localhost:4000/developer/glass/sitecore/2015/07/29/sitecore-razor-glass-attribute-helper-methods-fluent-api</id><content type="html" xml:base="http://localhost:4000/developer/glass/sitecore/2015/07/29/sitecore-razor-glass-attribute-helper-methods-fluent-api.html">&lt;p&gt;After blogging about creating some Sitecore Glass Attribute Helper Methods (&lt;a href=&quot;http://mikerobbins.co.uk/2015/05/21/sitecore-glass-attribute-helper-methods/&quot;&gt;Blog Post&lt;/a&gt;) to help front end developers add HTML attributes to Razor / Sitecore Glass Mapper controls. I had an interesting comment from Jim Noellsch, mentioning about turning the helper classes into a Fluent API.&lt;/p&gt;
&lt;p&gt;With a Fluent API, A developer is able to chain up multiple method calls, by returning the object on each method. See an example here for a better explanation than I can give &lt;a href=&quot;http://www.codeproject.com/Articles/640997/Fluent-interfaces-and-Method-Chaining-in-Csharp&quot; target=&quot;_blank&quot;&gt;http://www.codeproject.com/Articles/640997/Fluent-interfaces-and-Method-Chaining-in-Csharp&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;In the context of my attribute helper, this means that a developer can chain up multiple attributes into a single Dictionary. This gives the developer more flexibility of which attributes they want to use and are able to mix and match them.&lt;/p&gt;
&lt;p&gt;Below is the code for the Fluent API version of the html attribute helper classes.&lt;/p&gt;
&lt;p&gt;In the example .cshtml file you can see the API in use, as you can see we can chain up as many attribute methods calls are we like. To return the underlying Dictionary which is required for the @html helper controllers we call the Render() method.&lt;/p&gt;
&lt;p&gt;&lt;script src=&quot;https://gist.github.com/komainu85/d06240bf46d1f5e19b8b.js&quot;&gt; &lt;/script&gt;&lt;/p&gt;</content><author><name>{&quot;display_name&quot;=&gt;&quot;Mike Robbins&quot;, &quot;first_name&quot;=&gt;&quot;&quot;, &quot;last_name&quot;=&gt;&quot;&quot;, &quot;twitter&quot;=&gt;nil}</name></author><category term="developer" /><category term="MVC" /><category term="Razor" /><category term="Sitecore Glass" /><category term="Sitecore MVC" /><summary type="html">After blogging about creating some Sitecore Glass Attribute Helper Methods (Blog Post) to help front end developers add HTML attributes to Razor / Sitecore Glass Mapper controls. I had an interesting comment from Jim Noellsch, mentioning about turning the helper classes into a Fluent API. With a Fluent API, A developer is able to chain up multiple method calls, by returning the object on each method. See an example here for a better explanation than I can give http://www.codeproject.com/Articles/640997/Fluent-interfaces-and-Method-Chaining-in-Csharp. In the context of my attribute helper, this means that a developer can chain up multiple attributes into a single Dictionary. This gives the developer more flexibility of which attributes they want to use and are able to mix and match them. Below is the code for the Fluent API version of the html attribute helper classes. In the example .cshtml file you can see the API in use, as you can see we can chain up as many attribute methods calls are we like. To return the underlying Dictionary which is required for the @html helper controllers we call the Render() method.</summary></entry></feed>